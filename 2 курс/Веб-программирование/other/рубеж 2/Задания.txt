// Интерфейс на JSF для отображения ленты новостей

<html>
 <head>
   <title> 
     Новости
   </title>
 </head>
 <body>
    <div>
      <ui:repeat value="#{newsBean.allNews} var="news">
       <span>Название</span>
       <h:inputText value="#{newsBean.news.title/>
       <span>Новость</span>
       <h:inputText value="#{newsBean.news.description/>
       <span>Дата</span>
       <h:inputText value="#{newsBean.news.date/>
       <h:graphicImage value="#{newsBean.news.imageName}" library="images"/>
      </ui:repeat>
    </div>
    <br>
    <h1>Добавить новость</h1>
   <h:form>
    <div>
      <span>Введите название:</span>
      <h:inputText value="#{newsBean.title}" required="true/>
      <span>Введите описание:</span>
      <h:inputText value="#{newsBean.description}" required="true/>
      <span>Введите название изображения:</span>
      <h:inputText value="#{newsBean.imageName}" required="true/>
    </div>
    <h:commandButton value="Отправить" action="#{newsBean.addNews}>
   </h:form>
 </body>
</html>

import lombok;
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter
public class News {
 private String title;
 private String description;
 private String imageName;
 private Date date;
}


@ApplicationScoped
public class NewsBean {
 private String title;
 private String description;
 private String imageName;
 private Date date;
 private List<News> allNews = new ArrayList<>(); 
 public void addNews() {
 News news = new News(title, description, imageName, new Date())
 this.allNews.add(news)
 }
}


// Привести пример Java класса, 
   использующего передаваемый через 
   конструктор экземпляр JPA EntityMаnаger, 
   для реализации следующих операций со студентами 
   зачисление (создание), редактирование персональной информации, 
   отчисление (удаление), получение записи о студенте по идентификатору

import lombok;
@Getter
@Setter
@NoArgsConstructor
@Entity
public class Student {
 @Id
 @GeneratedValue(strategy = GenerationType.IDENTIFY)
 private Long id;
 
 private String name;
 
 public Student(String name) {
  this.name = name;
 }
}

public class StudentManager {
 private EntityManager em;
 public StudentManager(EntityManager em){
  this.em = em;
 }

 @Transactional
 public Student getStudentById(Long studentId) {
 retun em.find(Student.class, studentId)
 }

 @Transactional
 public void addStudent(String name) {
  em.persist(new Student(name));
 }

 @Transactional
 public Student deleteStudent(Long studentId) {
  Student studentToRemove = getStudentById(studentId);
  if (studentToRemove != null) em.remove(studentToRemove);
 }

 @Transactional
 public Student changeStudentInfo(Long studentId, String newName) {
 Student student = getStudentById(studentId);
 student.setName(newName);
 }
}


// angular компонент для аутентификации

 interface AuthRequest {
  username: string,
  password: string
 }

@Component(
selector: 'app-login',
imports: [FormsModule, CommonModule],
template: 
`
<form>
 <div *ngIf="errrorMessage"> 
 <label><text>{{errrorMessage}}</text></label>
 </div>
 <span>Введите имя пользователя:</span>
 <br>
 <label><text [(ngModel)]="username" type="text" name="username"></text></label>
 <br>
 <span>Введите имя пароль:</span>
 <br>
 <label><text [(ngModel)]="password" type="password" name="password"></text></label>
 <br>
 <button (click)="submitLogIn()">Войти</button>
</form>
`
)
export class LogInComponent {
 login = ''
 passwd = ''
 errrorMessage = ''

 constructor(private http: Http, private request: AuthRequest, private router: Router)
 submitLogIn() {
  this.request = {username: this.login, password: this.passwd}
  http.post<AuthRequest>("http://localhost:4200/app/auth/login", request).subscribe({
    next: (response) => {
     this.router.navigate(['points/'+response.id])
    }, 
    error: this.errorMessage = error.message
  })
 }
}




// react компонент для аутентификации

function LogInPage() {
 const [username, setUsername] = useState('')
 const [passwd, setPassword] = useState('')
 const [error, setError] = useState('')

 const submitForm = (e) => {
  e.preventDefault()
   const response = axios.post(
   'http://localhost:8080/app/auth/logIn',
   {login: username, password: passwd}
   ).then(response => useNavigate(`points/${response.id}`).catch(err => {
   if (err.error) {
   const message = err.error
   setError(message)
   }
  })
 }

 return (
 <div>
  <h1>Вход</h1>
  {error && <span>{error}</span>}
  <form onSubmit={submitForm}>
   <span>Введите логин:</span>
    <input value={username} onChange={(e) => setUsername(e.target.value)}/>
   <span>Введите пароль:</span>
    <input value={passwd} onChange={(e) => setPassword(e.target.value)}/>
    <button type='submit'>Отправить</button>
  </form>
 </div>
)
}



// Написать EJB, который просыпается в полночь и выводит содержимое таблицы н_люди

import lombok;
@Singleton
public class ShowPeopleBean {
 @PersistenceContext(unitName = 'pu')
 private EntityManager em;
 @Getter @Setter
 private String peopleList;

 @Schedule
 public void showPeopleAtMidnight() {
  StringBuilder sb = new StringBuilder();
  ArrayList<Person> people = em.createQuery("select p from Person p", Person.class).getResultSet();
  for (int i = 0; i < people.length; i++) {
   Person p = people[i];
   sb.append("ЧЛВК_" + i.toString() + ": " + p.name + "\n");
  }
  peopleList = sb.toString()
  System.out.println(peopleList)
 }
}
import lombok;
@Getter
@Setter
@Entity
@Table(name = "н_люди")
public class Person {
 @Id  
 @GeneratedValue(strategy = GenerationType.IDENTITY)
 private Long id;
 private String name;
}




// Написать конфиг JSF страницы,
   которая принимает xhtml запросы и все,
   чей url начинается на /faces/


<web-app>
 <servlet>
 <servlet-name>FacesServlet<servlet-name>
 <servlet-class>jakarta.servlet.FacesServlet<servlet-class>
 </servlet>
 <servlet-mapping>
  <servlet-name>FacesServlet<servlet-name>
  <url-pattern>*.xhtml</url-pattern>
 </servlet-mapping>
 <servlet-mapping>
   <servlet-name>FacesServlet<servlet-name>
   <url-pattern>/faces/*</url-pattern>
  </servlet-mapping>
</web-app>



// Написать компонент ejb для списания средств со счета
   клиента и начисления их на счет банка за одну
   транзакцию

@Stateless
public class BankTransactionBean() {
 @PersistenceContext(persistenceUnit = "pu")
 private EntityManager em;

 public void purchase(Client client, Bank bank, Double sum) {
  client.updateBalance(client.getBalance().subtract(sum));
  bank.updateBalance(bank.getWallet().add(sum));
  em.merge(client);
  em.merge(bank);
 }
}
или
@Stateless
public class BankTransactionBean() {
 @PersistenceContext(persistenceUnit = "pu")
 private EntityManager em;

 public void purchase(Long clientId, Long bankId, Double sum) {
  Client client = em.find(Client.class, clientId);
  Bank bank = em.find(Bank.class, bankId);

  client.updateBalance(client.getBalance().subtract(sum));
  bank.updateBalance(bank.getWallet().add(sum));
 }
}


// JSF Managed Bean, после инициализации HTTP-сессии
   формирующий коллекцию с содержимым таблицы
   Н_УЧЕБНЫЕ_ПЛАНЫ. Для доступа к БД необходимо
   использовать JDBC-ресурс jdbc/OrbisPool.

@Named
@SessionScoped
private class DataBean implements Serializable{
 @Resource("jdbc/OrbisPool")
 private DataSource dataSource;
 private ArrayList<StudyPlan> studyPlans;

 @PostConstruct
 public void init() throws SQLException {
  Connection connection = dataSource.getConnection();
  PreparedStatement st = connection.createQuery("select * from Н_УЧЕБНЫЕ_ПЛАНЫ");
  ResultSet rs = st.getResultSet();
  studyPlans = resultSetToList(rs);
 }
}

// Реализовать бин, который считает количество минут со
   старта приложения (или рестарта сервера)

@Named
@ApplicationScoped
public class CounterBean {
 private long startTime;
 public CounterBean() {
  startTime = System.currentTimeMillis();
 }
 public long getMinutesFromStart() {
  return (System.currentTimeMillis() - startTime) / 1000 / 60;
 }
}



// EJB калькулятор для 4-х операций
import lombok;
@Getter
@Setter
public class CalculatorEJB {
 private double a;
 private double b;
 private double ans;
 public getAns(){ return ans; }
 public float add(){ ans = a + b; }
 public float sub(){ ans = a - b; }
 public float mul(){ ans = a * b; }
 public float div(){ ans = a / b; }
}



// Создать бин, конфигурируемый аннотациями, с именем
   myBean, контекст которого равен контексту другого
   бина - myOtherBean
@Named
@Dependent # значит MyBean будет иметь контекст того, в кого его инжектят(наверное)
public class MyBean {
}

@Named
@ApplicationScoped
public class MyOtherBean {
  @Inject
  private MyBean myBean;
}


// Написать правило навигации, для перехода с одной
   страницы на другую по нажатию кнопки

<navigation-rule>
 <from-view-id>index.xhtml</from-view-id>
 <navigation-case>
  <from-outcome>main</from-outcome>
  <to-view-id>main.xhtml</to-view-id>
 <navigation-case>
</navigation-rule>



// JSF поле многострочного ввода в которое можно ввести
   только строчные английские буквы

<h:inputTextArea value="#{myBean.text}">
 <f:validateRegex pattern="^[a-z]*$"/>
</h:inputTextArea>


// Форма ПСЖ на angular

@Component ({
selector: 'app-expel-form'
imports: [FormsModule],
template:
`
<form>
 <div *ngIf=errorMessage><span>{{errorMessage}}</span></div>
 <span>Введите имя:</span>
 <input type="text" [(ngModel)]="name" value="name"/>
 <button type="submit" (click)="expel()">Прошу отчислить по собственному желанию<button>
</form>
`
})
export class ExpelFormComponent {
 name = ""
 constructor(private http: HttpClient, private router: Router) {}
 expel() {
  this.http.post("http://localhost:8080/app/main/expel", {name: this.name}).subscribe({
   next: response => {
    console.log(response)
    this.router.navigate(['/success'])
   },
   error: error => {
    this.errorMessage = error.error
   }
  })
 }
}


// сервис, который проверяет вошел
  ли пользователь и возвращал бы форму входа, при
  неавторизованности

@Injectable({
 providedIn: "root"
})
export class CheckAuthService {
 interface User = {
  id: string,
  name: string
 }
 constructor(private http: HttpClient, private router: Router) {}
 checkAuth(url: string, user: User) {
  this.http.post(url, {id: user.id, name: user.name}).subscribe({
  next: response => {
    if (!response.userIsAuth) {
     this.router.navigate(["/log-in"])
    }
   },
  error: {
    console.log(error.error)
    this.router.navigate(['/log-in'])
   }
  })
 }
}


// React компонент для хранения информации о
   банковской карте

interface BankCard {
 number: string,
 name: string,
 cvv: string
}
function BankCardComponent() {
 const [number, setNumber] = useState('')
 const [name, setName] = useState('')
 const [cvv, setCvv] = useState('')
 const submitCard = (e) => {
  e.preventDefault()
  console.log(number)
  console.log(name)
  console.log(cvv)
 }
 return (
<form onSubmit={submitCard}>
 <span>Введите номер карты:</span>
 <input type="text" onChange={(e) => setNumber(e.target.value)}/>
 <span>Введите имя владельца карты:</span>
 <input type="text" onChange={(e) => setName(e.target.value)}/>
 <span>Введите секретный код карты:</span>
 <input type="password" onChange={(e) => setCvv(e.target.value)}/>
</form>
)
}