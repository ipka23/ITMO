; Задание №1.
; Разработать программу для работы с элементами массива М, в которой:
; - каждый элемент является знаковым числом с разрядностью 23 бит;
; - элементы хранятся в массиве по границам слов, нет необходимости в плотной упаковке;
; 2. Для элементов массива необходимо вычислить одно значение по правилам:
; - агрегировать необходимо только для элементы массива с четными i-индексами;
; - из выбранных элементов необходимо вычислить максимальное значени записать результат в память поадресу 0x400.
; - Результатом является одно 32-х разрядное число!
; Примечание: все числа представлены в десятичной системе счисления, если явно не указано иное.


pointer: word 0x100
result_addr: word 0x030
arr_len: word 3
mask: word 0x007f            ; маска для обнуления битов с 23 по 31   0000 0000 0111 1111
sign_bit: word 0x0040       ; маска для проверки знака (22 бит)
;extend_sign: word 0xff80     ; расширение знака
mask2: word 0xff40           ; чтобы когда мы делали not у старшего слова было 0x00XX и при суммировании всё работало

start:
    cla
check_sign:
    ld pointer
    inc
    st pointer
    ld (pointer)        ; загружаем старшее слово
    cmp sign_bit
    ld pointer
    dec
    st pointer
    blt negative        ; [0x0080, 0x0040] - отриц.

main:
    ld (pointer)+       ; загружаем младшее слово
    add (result_addr)   ; прибавляем младшее слово результата
    st (result_addr)+   ; сохраняем сумму младших слов

    ld (pointer)+       ; загружаем старшее слово
    and mask
    adc (result_addr)   ; прибавляем старшее слово результата + С
    st (result_addr)    ; сохраняем сумму старших слов

    ld result_addr      ; сбрасываем указатель результата
    dec
    st result_addr
    loop arr_len
    jump main
    jump finish

negative:
    ld (pointer)+       ; загружаем младшее слово
    neg
    add (result_addr)   ; прибавляем младшее слово результата ;
    st (result_addr)+   ; сохраняем сумму младших слов

    ld (pointer)+       ; загружаем старшее слово
    or mask2
    not
    adc (result_addr)   ; прибавляем старшее слово результата + С
    st (result_addr)    ; сохраняем сумму старших слов

    ld result_addr      ; сбрасываем указатель результата
    dec
    st result_addr
    loop arr_len
    jump start

finish:
    hlt

org 0x030
result_sum: word 0x0000, 0x0000 ; org 0x030, org 0x031 ; 0030 0001 + 0015 2000 + 000f 4000 = 0054 6001

org 0x100
arr:                ; little-endian
word 0x1100, 0x0040 ; 0040 1100 ; i = 1
word 0x5010, 0x0070 ; 0070 5010 ; i = 2
word 0x0018, 0x0001 ; 0011 0018 ; i = 3